stack--> ordered, fixed datasize, "plate stack"
heap--> find space, return pointer --> allocating on the heap --> allocating

pointer to heap is down fixed size to can be store in the stack.

pushing to stack --> faster
allocating to heap --> slower
(hence why immut is standard?) 

owner out of scope --> value dropped

?? primitive datatypes --> fixed size --> stack? 

string literal != String
let s = String::from("hello"); //converts from string literal to String

string literal --> immut, hardcoded at compile, fast & efficient

let s1 = String::from("Hello");
let s2 = s1; //drops s1 pointer to "Hello" as to avoid future "double free error"  
  //let s2 = s1; --> called a "move"
print("{}", s1}; //will return error as pointer no longer exist.

??only with heap/complex data types?
  tested in copy-and-move --> is true

let s1 = String::from("Hello");
let s2 = s1.clone(); //clones value - memory heavy, but preserves s1


